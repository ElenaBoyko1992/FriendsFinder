1/ 43 урок - контейнерные и презентационные компоненты.
задача контейнерной компоненты удовлетворить нужды презентационной компоненты,
ради которой она и была создана. Задача контейнерной компоненты просто взять и
отрисовать презентационную компоненту и снабдить ее необходимыми данными
Презентационная компонента д.б. "чистая"(т.е. не получать ничего лишнего) и сильно не знависеть от конкретного BLL,
чтобы мы могли возможность переиспользовать её в каком-то другом коде.
А контейнерной компоненте наоборот, можно передать весь store, т.к. она "грязная" компонента.
Оборачиваем компоненту в контейнерную компоненту в том случае, если она выполняет какую-либо логику

2/ 44 урок - контекст.
Используется в случае, когда мы не хотим прокидывать пропсы через кучу компонент,
чтобы в итоге донести их до гр=лубоко вложенной компоненты, т.е. когда в приложении много
слоев компонент.
Используется не всегда, все подряд в него переносить не нужно, но может быть полезен для работы с какими-то
глобальными данными (store, изменить тему, язык и прочее.). Актуальный синтаксис объявления контекста смотреть
в документации реакта. Для меня пока в режиме ознакомления.

1. создание - см. файл StoreContext(архив)
2. оборачиваем App (к примеру) в <StoreContext.Provider value={/* some value */}>, после чего все дети
   обернутой компоненты смогут обращаться к данным из контекста напрямую
3. оборачиваем компоненту, которой нужны данные из контекста в <StoreContext.Consumer> (смотри пример в
   MyPostsContainer)

!!! export type ReduxStoreType = typeof store - команда для создания типа Store из Redux. См. файл redux-store.tsx

3/ 45 урок - библиотека React-Redux.
Имеет свой Provider (см. index.tsx). По-этому контекст вручную создавать больше не нужно.
connect возвращает нам новую контейнерную компоненту (см. файлы с контейнерными компонентами, напр. DialogsContainer)

пример создания контейнерной компоненты:
const DialogsContainer = connect(mapStateToProps, mapDispatchToProps) (Dialogs);// во вторых скобках помещаем
презентационную компоненту,
вокруг которой мы хотим создать контейнерную компоненту. Этой строчкой кода мы презентационную компоненту dialogs
законнектили к стору. А в первых скобках указаны функции, которые возвращают презент. компоненте нужные ей пропсы

4/ 47 урок -
store.subscribe(() => {
let state = store.getState();
rerenderEntireTree(state);
}) в index.tsx убираем, т.к. перерисовка теперь происходит за счет локального subscribe в connect контейнерной
компоненты.
НО ВАЖНО - для того, чтобы этот локальный subscribe срабатывал, т.е. происходила перерисовка, при изменении стейта
соблюдать принцип иммутабельности!

5/ 49 урок -
компонента Route отрисовывает указанную в ней компоненту или html-разметку, когда в адресной строке браузера появится
указанный в ее атрибуте адрес.
Если спросят на собесе, зачем нужна строка "import React from "react";", ответ - JSX не работает без реакта
Reducer - это чистая функция, которая принимает старый стейт и action и возвращает измененную копию стейта из этой
функции или старый стейт, если ничего менять не пришлось. Через Reducer идет модификация стейта.
Деструктурировать массив можно двумя путями - при помощи спред-оператора или при помощи .map()

Отрисовываем новую страницу с юзерами:

* Работа начинается с создания reducer (файл users-reducer)
* Далее в redux-store добавляем новую ветку стора (usersPage, которая обслуживается UsersReducer-ом)
* Если нашей новой компоненте нужны пропсы из стора, то мы делаем ее презентационной,
  и создаем над ней контейнерную компоненту (UsersContainer)




